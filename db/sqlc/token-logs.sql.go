// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: token-logs.sql

package db

import (
	"context"

	"github.com/oklog/ulid"
)

const addTokenLogs = `-- name: AddTokenLogs :one
INSERT INTO TokenLogs (
    Id, UserId, TokenId, ActionType
) VALUES (
    $1, $2, $3, $4
) RETURNING id, userid, tokenid, actiontype
`

type AddTokenLogsParams struct {
	ID         ulid.ULID    `json:"id"`
	Userid     ulid.ULID    `json:"userid"`
	Tokenid    ulid.ULID    `json:"tokenid"`
	Actiontype Tokenactions `json:"actiontype"`
}

func (q *Queries) AddTokenLogs(ctx context.Context, arg AddTokenLogsParams) (Tokenlog, error) {
	row := q.db.QueryRow(ctx, addTokenLogs,
		arg.ID,
		arg.Userid,
		arg.Tokenid,
		arg.Actiontype,
	)
	var i Tokenlog
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Tokenid,
		&i.Actiontype,
	)
	return i, err
}

const deleteTokenLog = `-- name: DeleteTokenLog :exec
DELETE FROM TokenLogs WHERE Id = $1
`

func (q *Queries) DeleteTokenLog(ctx context.Context, id ulid.ULID) error {
	_, err := q.db.Exec(ctx, deleteTokenLog, id)
	return err
}

const getTokenLogs = `-- name: GetTokenLogs :many
SELECT id, userid, tokenid, actiontype FROM TokenLogs
`

func (q *Queries) GetTokenLogs(ctx context.Context) ([]Tokenlog, error) {
	rows, err := q.db.Query(ctx, getTokenLogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tokenlog{}
	for rows.Next() {
		var i Tokenlog
		if err := rows.Scan(
			&i.ID,
			&i.Userid,
			&i.Tokenid,
			&i.Actiontype,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenLogsByActionType = `-- name: GetTokenLogsByActionType :many
SELECT id, userid, tokenid, actiontype FROM TokenLogs WHERE ActionType = $1
`

func (q *Queries) GetTokenLogsByActionType(ctx context.Context, actiontype Tokenactions) ([]Tokenlog, error) {
	rows, err := q.db.Query(ctx, getTokenLogsByActionType, actiontype)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tokenlog{}
	for rows.Next() {
		var i Tokenlog
		if err := rows.Scan(
			&i.ID,
			&i.Userid,
			&i.Tokenid,
			&i.Actiontype,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenLogsByTokenId = `-- name: GetTokenLogsByTokenId :many
SELECT id, userid, tokenid, actiontype FROM TokenLogs WHERE UserId = $1
`

func (q *Queries) GetTokenLogsByTokenId(ctx context.Context, userid ulid.ULID) ([]Tokenlog, error) {
	rows, err := q.db.Query(ctx, getTokenLogsByTokenId, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tokenlog{}
	for rows.Next() {
		var i Tokenlog
		if err := rows.Scan(
			&i.ID,
			&i.Userid,
			&i.Tokenid,
			&i.Actiontype,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenLogsByUserId = `-- name: GetTokenLogsByUserId :many
SELECT id, userid, tokenid, actiontype FROM TokenLogs WHERE TokenId = $1
`

func (q *Queries) GetTokenLogsByUserId(ctx context.Context, tokenid ulid.ULID) ([]Tokenlog, error) {
	rows, err := q.db.Query(ctx, getTokenLogsByUserId, tokenid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tokenlog{}
	for rows.Next() {
		var i Tokenlog
		if err := rows.Scan(
			&i.ID,
			&i.Userid,
			&i.Tokenid,
			&i.Actiontype,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
