// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tokens.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/oklog/ulid"
)

const addToken = `-- name: AddToken :one
INSERT INTO Tokens (
    Id, CreatorId, KeyId, TokenName, ExpiresAt
) VALUES ($1, $2, $3, $4, $5) RETURNING id, creatorid, keyid, tokenname, expiresat, isrevoked, revokedby, revokedat
`

type AddTokenParams struct {
	ID        ulid.ULID          `json:"id"`
	Creatorid ulid.ULID          `json:"creatorid"`
	Keyid     ulid.ULID          `json:"keyid"`
	Tokenname string             `json:"tokenname"`
	Expiresat pgtype.Timestamptz `json:"expiresat"`
}

func (q *Queries) AddToken(ctx context.Context, arg AddTokenParams) (Token, error) {
	row := q.db.QueryRow(ctx, addToken,
		arg.ID,
		arg.Creatorid,
		arg.Keyid,
		arg.Tokenname,
		arg.Expiresat,
	)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.Creatorid,
		&i.Keyid,
		&i.Tokenname,
		&i.Expiresat,
		&i.Isrevoked,
		&i.Revokedby,
		&i.Revokedat,
	)
	return i, err
}

const deleteToken = `-- name: DeleteToken :exec
DELETE FROM Tokens WHERE Id = $1
`

func (q *Queries) DeleteToken(ctx context.Context, id ulid.ULID) error {
	_, err := q.db.Exec(ctx, deleteToken, id)
	return err
}

const getActiveTokensByCreatorId = `-- name: GetActiveTokensByCreatorId :many
SELECT id, creatorid, keyid, tokenname, expiresat, isrevoked, revokedby, revokedat FROM Tokens
WHERE CreatorId = $1 AND IsRevoked = "false" AND ExpiresAt > now()
`

func (q *Queries) GetActiveTokensByCreatorId(ctx context.Context, creatorid ulid.ULID) ([]Token, error) {
	rows, err := q.db.Query(ctx, getActiveTokensByCreatorId, creatorid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Token{}
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Creatorid,
			&i.Keyid,
			&i.Tokenname,
			&i.Expiresat,
			&i.Isrevoked,
			&i.Revokedby,
			&i.Revokedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiredTokens = `-- name: GetExpiredTokens :many
SELECT id, creatorid, keyid, tokenname, expiresat, isrevoked, revokedby, revokedat FROM Tokens WHERE ExpiresAt <= now()
`

func (q *Queries) GetExpiredTokens(ctx context.Context) ([]Token, error) {
	rows, err := q.db.Query(ctx, getExpiredTokens)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Token{}
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Creatorid,
			&i.Keyid,
			&i.Tokenname,
			&i.Expiresat,
			&i.Isrevoked,
			&i.Revokedby,
			&i.Revokedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiredTokensByCreatorId = `-- name: GetExpiredTokensByCreatorId :many
SELECT id, creatorid, keyid, tokenname, expiresat, isrevoked, revokedby, revokedat FROM Tokens WHERE CreatorId = $1 AND ExpiresAt <= now()
`

func (q *Queries) GetExpiredTokensByCreatorId(ctx context.Context, creatorid ulid.ULID) ([]Token, error) {
	rows, err := q.db.Query(ctx, getExpiredTokensByCreatorId, creatorid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Token{}
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Creatorid,
			&i.Keyid,
			&i.Tokenname,
			&i.Expiresat,
			&i.Isrevoked,
			&i.Revokedby,
			&i.Revokedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvalidTokens = `-- name: GetInvalidTokens :many
SELECT id, creatorid, keyid, tokenname, expiresat, isrevoked, revokedby, revokedat FROM Tokens WHERE IsRevoked = "true" or ExpiresAt <= now()
`

func (q *Queries) GetInvalidTokens(ctx context.Context) ([]Token, error) {
	rows, err := q.db.Query(ctx, getInvalidTokens)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Token{}
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Creatorid,
			&i.Keyid,
			&i.Tokenname,
			&i.Expiresat,
			&i.Isrevoked,
			&i.Revokedby,
			&i.Revokedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvalidTokensByCreatorId = `-- name: GetInvalidTokensByCreatorId :many
SELECT id, creatorid, keyid, tokenname, expiresat, isrevoked, revokedby, revokedat FROM Tokens
WHERE CreatorId = $1 AND IsRevoked = "true" AND ExpiresAt <= now()
`

func (q *Queries) GetInvalidTokensByCreatorId(ctx context.Context, creatorid ulid.ULID) ([]Token, error) {
	rows, err := q.db.Query(ctx, getInvalidTokensByCreatorId, creatorid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Token{}
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Creatorid,
			&i.Keyid,
			&i.Tokenname,
			&i.Expiresat,
			&i.Isrevoked,
			&i.Revokedby,
			&i.Revokedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevokedTokens = `-- name: GetRevokedTokens :many
SELECT id, creatorid, keyid, tokenname, expiresat, isrevoked, revokedby, revokedat FROM Tokens WHERE IsRevoked = "true"
`

func (q *Queries) GetRevokedTokens(ctx context.Context) ([]Token, error) {
	rows, err := q.db.Query(ctx, getRevokedTokens)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Token{}
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Creatorid,
			&i.Keyid,
			&i.Tokenname,
			&i.Expiresat,
			&i.Isrevoked,
			&i.Revokedby,
			&i.Revokedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevokedTokensByCreatorId = `-- name: GetRevokedTokensByCreatorId :many
SELECT id, creatorid, keyid, tokenname, expiresat, isrevoked, revokedby, revokedat FROM Tokens WHERE CreatorId = $1 AND IsRevoked = "true"
`

func (q *Queries) GetRevokedTokensByCreatorId(ctx context.Context, creatorid ulid.ULID) ([]Token, error) {
	rows, err := q.db.Query(ctx, getRevokedTokensByCreatorId, creatorid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Token{}
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Creatorid,
			&i.Keyid,
			&i.Tokenname,
			&i.Expiresat,
			&i.Isrevoked,
			&i.Revokedby,
			&i.Revokedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenById = `-- name: GetTokenById :one
SELECT id, creatorid, keyid, tokenname, expiresat, isrevoked, revokedby, revokedat FROM Tokens WHERE Id = $1 LIMIT 1
`

func (q *Queries) GetTokenById(ctx context.Context, id ulid.ULID) (Token, error) {
	row := q.db.QueryRow(ctx, getTokenById, id)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.Creatorid,
		&i.Keyid,
		&i.Tokenname,
		&i.Expiresat,
		&i.Isrevoked,
		&i.Revokedby,
		&i.Revokedat,
	)
	return i, err
}

const getTokens = `-- name: GetTokens :many
SELECT id, creatorid, keyid, tokenname, expiresat, isrevoked, revokedby, revokedat FROM Tokens
`

func (q *Queries) GetTokens(ctx context.Context) ([]Token, error) {
	rows, err := q.db.Query(ctx, getTokens)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Token{}
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Creatorid,
			&i.Keyid,
			&i.Tokenname,
			&i.Expiresat,
			&i.Isrevoked,
			&i.Revokedby,
			&i.Revokedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokensByCreatorId = `-- name: GetTokensByCreatorId :many
SELECT id, creatorid, keyid, tokenname, expiresat, isrevoked, revokedby, revokedat FROM Tokens WHERE CreatorId = $1
`

func (q *Queries) GetTokensByCreatorId(ctx context.Context, creatorid ulid.ULID) ([]Token, error) {
	rows, err := q.db.Query(ctx, getTokensByCreatorId, creatorid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Token{}
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.ID,
			&i.Creatorid,
			&i.Keyid,
			&i.Tokenname,
			&i.Expiresat,
			&i.Isrevoked,
			&i.Revokedby,
			&i.Revokedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokensByTokenName = `-- name: GetTokensByTokenName :one
SELECT id, creatorid, keyid, tokenname, expiresat, isrevoked, revokedby, revokedat FROM Tokens WHERE TokenName = $1 LIMIT 1
`

func (q *Queries) GetTokensByTokenName(ctx context.Context, tokenname string) (Token, error) {
	row := q.db.QueryRow(ctx, getTokensByTokenName, tokenname)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.Creatorid,
		&i.Keyid,
		&i.Tokenname,
		&i.Expiresat,
		&i.Isrevoked,
		&i.Revokedby,
		&i.Revokedat,
	)
	return i, err
}

const markRevoked = `-- name: MarkRevoked :one
UPDATE Tokens
SET RevokedBy = $2, IsRevoked = "true"
WHERE Id = $1 AND IsRevoked = "false" AND RevokedAt = $3
RETURNING id, creatorid, keyid, tokenname, expiresat, isrevoked, revokedby, revokedat
`

type MarkRevokedParams struct {
	ID        ulid.ULID          `json:"id"`
	Revokedby pgtype.UUID        `json:"revokedby"`
	Revokedat pgtype.Timestamptz `json:"revokedat"`
}

func (q *Queries) MarkRevoked(ctx context.Context, arg MarkRevokedParams) (Token, error) {
	row := q.db.QueryRow(ctx, markRevoked, arg.ID, arg.Revokedby, arg.Revokedat)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.Creatorid,
		&i.Keyid,
		&i.Tokenname,
		&i.Expiresat,
		&i.Isrevoked,
		&i.Revokedby,
		&i.Revokedat,
	)
	return i, err
}
